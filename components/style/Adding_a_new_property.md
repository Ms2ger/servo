% The Servo style system: an overview

It's in the components/style directory. Two other pieces are the cssparser and the syntax piece. It knows about @-rules and qualified rules. The definition of every property is not in the css parser or the syntax module. The definition of properties are in the servo style crates.

The part that's interesting to people is how to add a new property. For that, there's a property subdir in the style crate. There is a lot of generated code here because there is code that wants to do things for every property. This code predates the compilers plugin system, and macros are not strong enough. So instead there is a python library that has a mako file that generates Rust code. In the process, it generate code from the properties.

There are two directories; longhands and shorthands. Inside longhands, there is one file per style struct. Properties are divided per style struct, as in Gecko, to save memory. If you look at the background-color definition, you can see that there are blocks for each value. Each value expands to a rust module per property. There will be one Rust type per property (though they can be same for ones that are similar). There is one for the specified value, which is what is parsed from the spreadsheet. There is also one of the computed value. There is a submodule for the computed value, called T. There can be more things here sometimes, but that is what is used from layout. In the ToCss trait there is a definition of how to serialize the values. There is also an initial_value function that defines how to initialize things.

Most interesting is the function to parse the values. The idea of the CSS parser is that you get a struct of type cssparser::Parser. There is a next method that defines a Result. If you are at the end of the input you get Nothing. Otherwise, there is an enum with the Token. The cssparser crate takes care of escaping inside of CSS. The idea is that cssparsing is centered around the Result type. That has values Ok or an Err. Typically, you will have a bunch of functions that have a Result of something. We use functions that return these so that we can use the try function. So, you call input.try to see if you get the expected value, and then fail otherwise.

If you are adding a new property, you will write a new block of code in this macro file and based on the specification you will parse things per the spec. e.g., background-image supports comma-separated bg-image. So you would go to the parse method for the background-image property. You get input, which is a parser. So you will call try, giving it a closure and then call expect_ident_matching if needed. Otherwise, you can just call next and check the value, but the expect_* cases handle checking for common cases. In this case, we want the identifier "none", and the expect_ident_matching thing works. If that fails, then the try method takes care of rewinding the parser to the position it was at in the start. So, you can check for a variant and try the other ones. If the parse failed, then we attempt to wrap up the input into an Image enum and then return it.

try can handle restoration of position even if there were more than one item.

Q: does it emit tokens? A: Emits computed values.

The tokens list also contains blocks, e.g., ParenthesisBlock. It is nullary (has no arguments). So, if you have one of those you call a special method, parse_nested_block. After you get one, you call that. So, if you get a paren block, you might be looking at linear-gradient, call parse_nested_block, and then you can parse the function inside it. If you have nested parenthesis or blocks, the cssparser will handle the matching of them. parse_nested_block will ensure that you have parsed it all. For example, you might have more stuff after the close parenthesis until the end of the block. It will ensure that you consume it all. This validation is also present for things that are not nested blocks, e.g., that normal properties declaration do not have extra gunk at the end. This is done by the function parse_entirely. It is only used in the code that parses blocks of property declarations.

There are many other convenience methods in the parser type, but those are the important ones.

The other thing that we have to write for every property is how to convert a specified value to a computed value. Done in a trait. The common patterns have been implemented as a function. You can also fall back to python where needed to generate code. When the property value is only one of a few keywords, there is a helper.single_keyword python-level function that defines them all automatically. There is one that has gecko-only code. product = "gecko" in this file means that it is supported only for stylo. These are just python strings, so you can have python code to do conditional things.

Q: python mako stuff forever We'd like to move it to something that more cleanly separates the definition of the property from the code generation. Possibly from the Rust compiler's libsyntax would be great. However, what we have for now works and is very flexible. Also, Rust's libsyntax is not stable (or on the stability path) and would require that the style system is on nightly Rust instead of stable.

The helpers like single_keyword are defined in the properties directory in helpers.mako.rs. There are some python loops over the keywords in this code, but you should generally not need to look at it. In the cases where the specified value is the same as the computed value, there is a marker trait ComputedValueAsSpecified that lets you skip implementing to_computed_value.

In the CSS cascade spec, there are different stages of value. They are not all represented directly during value processing. The idea of computed values is that they are the value for one element. So length can have an em unit, which is based on the font size. The computed value CANNOT depend on layout. If you have auto, it will remain the computed value . Those are called used values. Those are not represented explicitly. In the case of width, on flows in the layout code in servo, we have a rectangle that corresponds to the size of the flow, and that is where the used value for the width is. So the used value is max_width and width is the computed value.

In some cases the used value will depend on layout. So the computed values can contain a percentage. But, in other cases, e.g., line-height, they can refer to the font size, in which case they can be expanded.

The intended definition of computed values is to be computed without performing layout. Computed values stay within the CSS system. Used values need the layout system. There are some places where getComputedValue may return one or another from script, but that should not be read as related to computed vs. used values in styles.

How about display when it depends on {?}? In properties.mako.rs, we have the cascade, which is where we deal with that. In cascade, there is stuff for every declaration. We create a computed Context, which is what's given to the computed values method. In that context, we have things like the whether something is_root_element, the viewport_size, the initial_style, and the actual style that is currently being computed. The early properties are the ones you need first because the other ones depend on them. There are only two phases. font-size is one of the early ones. In gecko, there is a thing that resolves the dependencies at compile-time and generates code that handles these dependencies. Ours is closer to the WebKit design. There are not many dependencies other than em, but some of the alignment ones depend on properties on the parents. We have some limitations in the style crate where the initial values are represented in the computed values, since they are often used as inherited values. In that case, using the computed value works well. In some cases, e.g., border-*-width, the initial value is medium, but the computed value step says that if the style is not medium, then the width should be 0. So we have an initial value, but we need to change it at the end of the function if it's still there. In that case, we have a fixup function.

Ideally, the computed value type would have more information about whether they were initial or not. Possibly, we should do initial values as specified types... It's possibly better to stick with Auto, but then it might leak into other modules and possibly lead to dangerous wildcard patterns.

Unfortunately, dependencies are all called out in prose in the spec, not in the actual blocks defining the properties. So, it's hard to build things that auto-check or mechanize things. That said, it should all be in the spec so that the PR author or reviewer can notice.

Q: do we traverse the tree twice for early vs other properties? No, for a given element, go over all properties that apply early. Then a second time for the other ones.
Stylo

For stylo, when you define a property using those blocks, one of the parameters is products. The default is both. But, you can define it as product="servo" or product="gecko". That's all that's needed to define properties for just one or the other engine. There are some cases where the property is in both with different sets of values. That is where in the definition there is python code that does if product == "gecko". Finally, there is a gecko_ffi_name, which calls out where the gecko style structs have a different member name than the Servo ones. There's also some code that will capitalize things, add ms, and add underscores, and that typically works. But when the property is float, we would generate mFloat but it should be called mFloats in Gecko. In that case, name of the rust identifier in Servo is generated from the CSS name and does not match the Gecko internal name.

For stylo, there is a different toplevel crate. In the servo repository, it is in ports/geckolib. It also has some mako templates for some FFI things in stylo. That loads in the default templates and adds on to them.
